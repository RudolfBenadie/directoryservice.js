"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utilities = require("../utilities");

var _Logger = _interopRequireDefault(require("../Logger"));

var _factories = require("../factories");

var _symbols = require("../symbols");

var _errors = require("../errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = _Logger.default.child({
  namespace: 'sql'
});
/* eslint-disable complexity */
// $FlowFixMe


const sql = (parts, ...values) => {
  let rawSql = '';
  const parameterValues = [];
  let index = 0;

  for (const part of parts) {
    const token = values[index++];
    rawSql += part;

    if (index >= parts.length) {
      continue;
    }

    if ((0, _utilities.isPrimitiveValueExpression)(token)) {
      rawSql += '$' + (parameterValues.length + 1);
      parameterValues.push(token);
    } else if ((0, _utilities.isSqlToken)(token)) {
      // $FlowFixMe
      const sqlFragment = (0, _factories.createSqlTokenSqlFragment)(token, parameterValues.length);
      rawSql += sqlFragment.sql;
      parameterValues.push(...sqlFragment.values);
    } else {
      log.error({
        constructedSql: rawSql,
        offendingToken: token
      }, 'unexpected value expression');
      throw new TypeError('Unexpected value expression.');
    }
  }

  if (rawSql.trim() === '') {
    throw new _errors.InvalidInputError('Unexpected SQL input. Query cannot be empty.');
  }

  if (rawSql.trim() === '$1') {
    throw new _errors.InvalidInputError('Unexpected SQL input. Query cannot be empty. Found only value binding.');
  }

  const query = (0, _utilities.deepFreeze)({
    sql: rawSql,
    type: _symbols.SqlTokenSymbol,
    values: parameterValues
  });
  return query;
};

sql.identifier = names => {
  // @todo Replace `type` with a symbol once Flow adds symbol support
  // @see https://github.com/facebook/flow/issues/810
  return (0, _utilities.deepFreeze)({
    names,
    type: _symbols.IdentifierTokenSymbol
  });
};

sql.identifierList = identifiers => {
  return (0, _utilities.deepFreeze)({
    identifiers,
    type: _symbols.IdentifierListTokenSymbol
  });
};

sql.raw = (rawSql, values) => {
  return (0, _utilities.deepFreeze)({
    sql: rawSql,
    type: _symbols.RawSqlTokenSymbol,
    values: values || []
  });
};

sql.valueList = values => {
  return (0, _utilities.deepFreeze)({
    type: _symbols.ValueListTokenSymbol,
    values
  });
};

sql.array = (values, memberType) => {
  return (0, _utilities.deepFreeze)({
    memberType,
    type: _symbols.ArrayTokenSymbol,
    values
  });
};

sql.tuple = values => {
  return (0, _utilities.deepFreeze)({
    type: _symbols.TupleTokenSymbol,
    values
  });
};

sql.tupleList = tuples => {
  return (0, _utilities.deepFreeze)({
    tuples,
    type: _symbols.TupleListTokenSymbol
  });
};

sql.unnest = (tuples, columnTypes) => {
  return (0, _utilities.deepFreeze)({
    columnTypes,
    tuples,
    type: _symbols.UnnestTokenSymbol
  });
};

sql.booleanExpression = (members, operator) => {
  return (0, _utilities.deepFreeze)({
    members,
    operator,
    type: _symbols.BooleanExpressionTokenSymbol
  });
};

sql.comparisonPredicate = (leftOperand, operator, rightOperand) => {
  return (0, _utilities.deepFreeze)({
    leftOperand,
    operator,
    rightOperand,
    type: _symbols.ComparisonPredicateTokenSymbol
  });
};

sql.assignmentList = namedAssignment => {
  return (0, _utilities.deepFreeze)({
    namedAssignment,
    type: _symbols.AssignmentListTokenSymbol
  });
};

var _default = sql;
exports.default = _default;
//# sourceMappingURL=sql.js.map