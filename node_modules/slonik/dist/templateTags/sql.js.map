{"version":3,"sources":["../../src/templateTags/sql.js"],"names":["log","Logger","child","namespace","sql","parts","values","rawSql","parameterValues","index","part","token","length","push","sqlFragment","error","constructedSql","offendingToken","TypeError","trim","InvalidInputError","query","type","SqlTokenSymbol","identifier","names","IdentifierTokenSymbol","identifierList","identifiers","IdentifierListTokenSymbol","raw","RawSqlTokenSymbol","valueList","ValueListTokenSymbol","array","memberType","ArrayTokenSymbol","tuple","TupleTokenSymbol","tupleList","tuples","TupleListTokenSymbol","unnest","columnTypes","UnnestTokenSymbol","booleanExpression","members","operator","BooleanExpressionTokenSymbol","comparisonPredicate","leftOperand","rightOperand","ComparisonPredicateTokenSymbol","assignmentList","namedAssignment","AssignmentListTokenSymbol"],"mappings":"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","sourcesContent":["// @flow\n\nimport type {\n  ArraySqlTokenType,\n  AssignmentListTokenType,\n  BooleanExpressionTokenType,\n  ComparisonOperatorType,\n  ComparisonPredicateTokenType,\n  IdentifierListMemberType,\n  IdentifierListTokenType,\n  IdentifierTokenType,\n  LogicalBooleanOperatorType,\n  NamedAssignmentType,\n  PrimitiveValueExpressionType,\n  RawSqlTokenType,\n  SqlSqlTokenType,\n  SqlTaggedTemplateType,\n  TupleListSqlTokenType,\n  TupleSqlTokenType,\n  UnnestSqlTokenType,\n  ValueExpressionType,\n  ValueListSqlTokenType\n} from '../types';\nimport {\n  deepFreeze,\n  isPrimitiveValueExpression,\n  isSqlToken\n} from '../utilities';\nimport Logger from '../Logger';\nimport {\n  createSqlTokenSqlFragment\n} from '../factories';\nimport {\n  ArrayTokenSymbol,\n  AssignmentListTokenSymbol,\n  BooleanExpressionTokenSymbol,\n  ComparisonPredicateTokenSymbol,\n  IdentifierListTokenSymbol,\n  IdentifierTokenSymbol,\n  RawSqlTokenSymbol,\n  SqlTokenSymbol,\n  TupleListTokenSymbol,\n  TupleTokenSymbol,\n  UnnestTokenSymbol,\n  ValueListTokenSymbol\n} from '../symbols';\nimport {\n  InvalidInputError\n} from '../errors';\n\nconst log = Logger.child({\n  namespace: 'sql'\n});\n\n/* eslint-disable complexity */\n// $FlowFixMe\nconst sql: SqlTaggedTemplateType = (\n  parts: $ReadOnlyArray<string>,\n  ...values: $ReadOnlyArray<ValueExpressionType>\n): SqlSqlTokenType => {\n  let rawSql = '';\n\n  const parameterValues = [];\n\n  let index = 0;\n\n  for (const part of parts) {\n    const token = values[index++];\n\n    rawSql += part;\n\n    if (index >= parts.length) {\n      continue;\n    }\n\n    if (isPrimitiveValueExpression(token)) {\n      rawSql += '$' + (parameterValues.length + 1);\n\n      parameterValues.push(token);\n    } else if (isSqlToken(token)) {\n      // $FlowFixMe\n      const sqlFragment = createSqlTokenSqlFragment(token, parameterValues.length);\n\n      rawSql += sqlFragment.sql;\n      parameterValues.push(...sqlFragment.values);\n    } else {\n      log.error({\n        constructedSql: rawSql,\n        offendingToken: token\n      }, 'unexpected value expression');\n\n      throw new TypeError('Unexpected value expression.');\n    }\n  }\n\n  if (rawSql.trim() === '') {\n    throw new InvalidInputError('Unexpected SQL input. Query cannot be empty.');\n  }\n\n  if (rawSql.trim() === '$1') {\n    throw new InvalidInputError('Unexpected SQL input. Query cannot be empty. Found only value binding.');\n  }\n\n  const query = deepFreeze({\n    sql: rawSql,\n    type: SqlTokenSymbol,\n    values: parameterValues\n  });\n\n  return query;\n};\n\nsql.identifier = (\n  names: $ReadOnlyArray<string>\n): IdentifierTokenType => {\n  // @todo Replace `type` with a symbol once Flow adds symbol support\n  // @see https://github.com/facebook/flow/issues/810\n  return deepFreeze({\n    names,\n    type: IdentifierTokenSymbol\n  });\n};\n\nsql.identifierList = (\n  identifiers: $ReadOnlyArray<IdentifierListMemberType>\n): IdentifierListTokenType => {\n  return deepFreeze({\n    identifiers,\n    type: IdentifierListTokenSymbol\n  });\n};\n\nsql.raw = (\n  rawSql: string,\n  values?: $ReadOnlyArray<ValueExpressionType>\n): RawSqlTokenType => {\n  return deepFreeze({\n    sql: rawSql,\n    type: RawSqlTokenSymbol,\n    values: values || []\n  });\n};\n\nsql.valueList = (\n  values: $ReadOnlyArray<ValueExpressionType>\n): ValueListSqlTokenType => {\n  return deepFreeze({\n    type: ValueListTokenSymbol,\n    values\n  });\n};\n\nsql.array = (\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  memberType: string\n): ArraySqlTokenType => {\n  return deepFreeze({\n    memberType,\n    type: ArrayTokenSymbol,\n    values\n  });\n};\n\nsql.tuple = (\n  values: $ReadOnlyArray<ValueExpressionType>\n): TupleSqlTokenType => {\n  return deepFreeze({\n    type: TupleTokenSymbol,\n    values\n  });\n};\n\nsql.tupleList = (\n  tuples: $ReadOnlyArray<$ReadOnlyArray<ValueExpressionType>>\n): TupleListSqlTokenType => {\n  return deepFreeze({\n    tuples,\n    type: TupleListTokenSymbol\n  });\n};\n\nsql.unnest = (\n  tuples: $ReadOnlyArray<$ReadOnlyArray<PrimitiveValueExpressionType>>,\n  columnTypes: $ReadOnlyArray<string>\n): UnnestSqlTokenType => {\n  return deepFreeze({\n    columnTypes,\n    tuples,\n    type: UnnestTokenSymbol\n  });\n};\n\nsql.booleanExpression = (\n  members: $ReadOnlyArray<ValueExpressionType>,\n  operator: LogicalBooleanOperatorType\n): BooleanExpressionTokenType => {\n  return deepFreeze({\n    members,\n    operator,\n    type: BooleanExpressionTokenSymbol\n  });\n};\n\nsql.comparisonPredicate = (\n  leftOperand: ValueExpressionType,\n  operator: ComparisonOperatorType,\n  rightOperand: ValueExpressionType\n): ComparisonPredicateTokenType => {\n  return deepFreeze({\n    leftOperand,\n    operator,\n    rightOperand,\n    type: ComparisonPredicateTokenSymbol\n  });\n};\n\nsql.assignmentList = (\n  namedAssignment: NamedAssignmentType\n): AssignmentListTokenType => {\n  return deepFreeze({\n    namedAssignment,\n    type: AssignmentListTokenSymbol\n  });\n};\n\nexport default sql;\n"],"file":"sql.js"}