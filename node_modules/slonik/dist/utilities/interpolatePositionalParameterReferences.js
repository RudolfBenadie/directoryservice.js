"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _errors = require("../errors");

var _factories = require("../factories");

var _isSqlToken = _interopRequireDefault(require("./isSqlToken"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @see https://github.com/mysqljs/sqlstring/blob/f946198800a8d7f198fcf98d8bb80620595d01ec/lib/SqlString.js#L73
 */
const interpolatePositionalParameterReferences = (inputSql, inputValues = [], greatestParameterPosition) => {
  const resultValues = [];
  const bindingNames = (inputSql.match(/\$(\d+)/g) || []).map(match => {
    return parseInt(match.slice(1), 10);
  }).sort();

  if (bindingNames[bindingNames.length - 1] > inputValues.length) {
    throw new _errors.UnexpectedStateError('The greatest parameter position is greater than the number of parameter values.');
  }

  if (bindingNames.length > 0 && bindingNames[0] !== 1) {
    throw new _errors.UnexpectedStateError('Parameter position must start at 1.');
  }

  const resultSql = inputSql.replace(/\$(\d+)/g, (match, g1) => {
    const parameterPosition = parseInt(g1, 10);
    const boundValue = inputValues[parameterPosition - 1];

    if ((0, _isSqlToken.default)(boundValue)) {
      // $FlowFixMe
      const sqlFragment = (0, _factories.createSqlTokenSqlFragment)(boundValue, resultValues.length + greatestParameterPosition);
      resultValues.push(...sqlFragment.values);
      return sqlFragment.sql;
    } else {
      resultValues.push(inputValues[parameterPosition - 1]);
      return '$' + (resultValues.length + greatestParameterPosition);
    }
  });
  return {
    sql: resultSql,
    values: resultValues
  };
};

var _default = interpolatePositionalParameterReferences;
exports.default = _default;
//# sourceMappingURL=interpolatePositionalParameterReferences.js.map